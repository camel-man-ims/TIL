# chap8 - 클래스 계층과 상속

## 0. 도입

* 정적타입 언어인 코틀린은 명세에 따른 설계를 장려한다.
* 클래스는 기본적으로 final이며, 상속을 할거면 open을 사용해야 한다.
* sealed를 정의하여 확장할 수 있는 특정 클래스를 명시해줄 수 있다.

## 1. 인터페이스와 추상 클래스 생성

* [주요 코드 및 설명 chap8-1](./codes/chap8/chap8-1-remote.kt)
  * 인터페이스에 대한 주요 동작 설명
* 객체 지향 프로그래밍이란, 추상화 개념을 바탕으로 프로그래밍 하는 것이다.
* 인터페이스 vs 추상클래스
  * 인터페이스엔 백킹 필드가 없다.
  * 추상 클래스는 백킹 필드를 가진다.
  * 여러 클래스 사이에서 상태를 다시 사용해야 한다면 추상 클래스가 좋은 선택이다.
  * 각각의 클래스들이 각각의 구현 사항을 원한다면 인터페이스가 좋은 선택이다.
  * 모던 자바와 코틀린 양쪽에서 인터페이스가 추상 클래스보다 약간의 이점을 갖고 있다.
    * 인터페이스는 메소드를 상태와 상관없이 구현할 수 있는 능력이 있다.
    * 유연성을 위해서 가능하다면 추상 클래스나 베이스 클래스를 사용하는 것 보다는 인터페이스를 사용하는 것이 낫다.

## 2. 중첩 클래스와 내부 클래스

* [주요 코드 및 설명 chap8-2](./codes/chap8/chap8-2-inner.kt)
  * TvV2
    * inner class를 getter()의 생성자에 넣어주기
  * TvV3
    * TvV2의 코드를 익명 클래스로 사용하기
* `super@Outer` 문법은 자주 사용해서는 안된다.
  * 이런 설계는 다형성의 의미와 메서드 오버라이드의 의도를 저버리고, 클래스의 베이스 클래스로 바이패스를 해주기 때문에 오류가 많아진다.

## 3. 상속

* [상속 코드 설명 chap8-3](./codes/chap8/chap8-3-interitance.kt)
* 코틀린은 클래스가 어쩌다 베이스 클래스로서 동작하는 것을 원하지 않는다.
  * 코틀린은 클래스 default가 final이다.
  * 상속을 해줄거면 open이라고 명시를 해주어야 한다.
* 메소드를 override할 때, final override를 명시하면 이후 서브 클래스가 해당 메소드를 override하는 것을 방지할 수 있다.
* var로 정의된 속성은 var로만 override 할 수 있다.
  * 왜냐하면 val은 getter만 갖고 있고,var로 생성한 속성을 val로 override하면서 setter를 제거할 수 없기 때문이다.

## 4. sealed class

* [sealed class](./codes/chap8/chap8-4-sealed.kt)
* 클래스를 만들 때 작성자가 지정한 몇몇 클래스에만 상속할 수 있도록 하는 중간 영역의 클래스이다.
* 동일한 파일에 작성된 다른 클래스들에 확장이 허용되지만, 그 외 클래스들은 확장할 수 없다.
* sealed 클래스의 생성자는 private으로 취급되기 때문에, 해당 클래스로부터 객체를 인스턴스화 할 수 없다.
* sealed 클래스를 사용하여 when을 표현할 때는 else를 사용하지 마라.
  * 왜냐하면 else를 추가하면 나중에 sealed클래스가 추가됐을 때 새로운 케이스가 추가됐음을 알리는 컴파일 오류가 나타나지 않고, 의도에 따라 동작하지 않을 확률이 높다.

## 5. enum

* [enum](./codes/chap8/chap8-5-enum.kt)

